function makeTexture_ImgTexture

%display texture made out of an image

global screenPTR Gtxtr Masktxtr IDim screenNum Mstate
global Gseq loopTrial

if ~isempty(Gtxtr)
    Screen('Close',Gtxtr);  %First clean up: Get rid of all textures/offscreen windows
end
if ~isempty(Masktxtr)
    Screen('Close',Masktxtr);  %First clean up: Get rid of all textures/offscreen windows
end

Gtxtr = [];
Masktxtr=[];
Gseq = [];
IDim=[];

%get parameters
P = getParamStruct;
screenRes = Screen('Resolution',screenNum);

%create the mask 
xN=deg2pix(P.x_size,'round');
yN=deg2pix(P.y_size,'round');
mN=deg2pix(P.mask_radius,'round');

mask=makeMask(screenRes,P.x_pos,P.y_pos,xN,yN,mN,P.mask_type,P.background);
Masktxtr = Screen(screenPTR, 'MakeTexture', mask,[],[],2);  %need to specify correct mode to allow for floating point numbers


%load images 
load([P.stimfile '.mat']);

%get bar profile and bar width
didx=find(d==P.distance);
if isempty(didx)
    didx=1; %60cm
end

lidx=find(l==P.length);
if isempty(lidx)
    lidx=3; %dir 0
end

midx=find(m==P.material);
if isempty(midx)
    midx=1; %material 1
end

sidx=find(s==P.barWidth);
if isempty(sidx)
    sidx=5; %0.5
end

cSingle=st{sidx,midx,didx,lidx};
cSingle=double(cSingle)./255;

cSize=size(cSingle);

%compute block width (each texture element will sit inside a block at a
%random offset)
blockWidthX=cSize(2)+P.deltaX;
blockWidthY=cSize(1)+P.deltaY;

%replicate line that is large enough to span the stimulus size, plus an
%extra cycle
%stimuli will need to be larger to deal with rotation
stimsize=2*sqrt((P.x_size/2).^2+(P.y_size/2).^2); %deg
stimsizeN=deg2pix(stimsize,'ceil'); %pixel

%turn this into nr of cycles
nCyclesX=ceil(stimsizeN/blockWidthX);
nCyclesY=ceil(stimsizeN/blockWidthY);

%now build image (need an extra cycle for x for movement)
textMat=ones(nCyclesY*blockWidthY,(nCyclesX+1)*blockWidthX)*P.background;

%generate random offsets for each block
s = RandStream.create('mrg32k3a','NumStreams',1,'Seed',datenum(date)+1000*str2double(Mstate.unit)+str2double(Mstate.expt)+P.rseed);
randoff=rand(s,[2,nCyclesX*nCyclesY]);
Gseq.randoff=randoff;

%generate all but the last cycle (will need to be copied from start)
for i=1:nCyclesX
    for j=1:nCyclesY
        %top left position
        startX = (i-1)*blockWidthX+1; %regular grid
        startX = startX+P.noiseX*randoff(1,(i-1)*nCyclesY+j)*P.deltaX; %add noise, max shift to the right is blockWidth-imgWidth
        
        %top right position
        startY = (j-1)*blockWidthY+1;
        startY = startY+P.noiseY*randoff(2,(i-1)*nCyclesY+j)*P.deltaY; %add noise, max shift to the right is blockWidth-imgWidth
        
    end
end
        
    





%generate texture
Gtxtr = Screen(screenPTR, 'MakeTexture', barPattern,[],[],2);


%save sequence data
if Mstate.running
    saveLog(Gseq,P.rseed,loopTrial)  %append log file with the latest sequence
end







